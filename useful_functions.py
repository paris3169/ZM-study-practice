# -*- coding: utf-8 -*-
"""useful_functions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hPTNzFhUbEUnrT3kygq3WPPVJ0RaOcTY
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import pandas as pd
import os
import datetime
import random
import tensorflow as tf

import pathlib
import zipfile

def unzip_data(filename):
  zip_ref=zipfile.ZipFile(filename, mode="r")
  zip_ref.extractall()
  zip_ref.close()

def fetch_random_image(target_dir):
  """ this is return a random image selected in a random subdirectory from the specified target dir

      Args:
        target_dir: the specified directory where images are stored (in subfolder per class)
      outputs:
        image_path: full path of the randomly chosen image
        image_label: the class names the selected image belongs to
  """
  
  random_sub_dir=random.choice(os.listdir(target_dir))
  target_dir=os.path.join(target_dir,random_sub_dir)
  image=random.choice(os.listdir(target_dir))
  image_path=os.path.join(target_dir,image)
  return image_path, random_sub_dir

def show_image(image_path,image_class,height=10,width=10):
  """
      Visualize the image and the class it belongs to

      Args:
        image_path: full image path name
        image_class: class name of the image
        figsize=(image_height,image_width) default is (10,10)

      output:
        display the image (with full image path and class name as title)
        print out the image_tensor shape
    
  """
  img=tf.io.read_file(image_path)   #this is reading the file
  img_tf=tf.io.decode_image(img)    #this is decoding the image into a tensor diffrently from plt.imread which is generating a numpy array
  
  #display the image
  plt.figure(figsize=(height,width))
  plt.imshow(img_tf)
  plt.title(f"file_name {image_path}\nimage_class: {image_class}")
  plt.grid(False)

def image_load_preprocess(image_path,height=None,width=None,scaling=False):
  """
    this function is loading an image from specified image_path, is decoding into a tensor of image size defined by tuple image_size (default is (224,224)) 
    and is expanding the dimensionality as requested by NN model (1,height, width, color_channels)
    If scaleing == True that also scaling of image is performed (i.e. multiplying for 1/255.)

    Args:
      image_path is the full filename of the image to load
      height, width of the image for resizing (in case heigh and width are provided)
      scaling = True to rescale the image

    output:
      a tensor of floats (between 0 and 1 if sclaing is True) with dimension like (1,height,width,3) ready to be fed intpo the NN model for predictions
  """
  #reading the image and decoding into a tensor
  image=tf.io.read_file(image_path)
  image_tf=tf.io.decode_image(image)
  if (height and width) is not None:
    image_tf=tf.keras.layers.experimental.preprocessing.Resizing(height=224,width=224)(image_tf)
  print(f"image shape: {image_tf.shape}")

  #rescaling the image tensor if requested
  if scaling==True:
    image_tf=image_tf*(1/255.)

  #extending the dimensionality of the tensor into the shape (1,height, width,3)
  extended_image_tf=tf.expand_dims(image_tf,axis=0)
  print(f"extended image shape: {extended_image_tf.shape}")

  return extended_image_tf


def visualize_before_after(original_image,new_image,resize=False):
  """
    this fuxcntion is visualizing the difference between the original image and the new image
  """

  print(f"original image shape: {original_image.shape}")
  plt.figure(figsize=(10,10))
  plt.imshow(original_image)
  plt.title("original image")

  #resize the new_image if needed (resize=True)
  if resize==True:
    scaling_factor=255
  else:
    scaling_factor=1 
  final_image=tf.cast(new_image,dtype=tf.int32)*scaling_factor
  #display the new image
  print(f"final Image shape: {final_image.shape}")
  plt.figure(figsize=(10,10))
  plt.imshow(final_image)
  plt.title("output_image")

def compare_historys(original_history, new_history, initial_epochs=5):
    """
    Compares two model history objects.
    """
    # Get original history measurements
    acc = original_history.history["accuracy"]
    loss = original_history.history["loss"]

    print(len(acc))

    val_acc = original_history.history["val_accuracy"]
    val_loss = original_history.history["val_loss"]

    # Combine original history with new history
    total_acc = acc + new_history.history["accuracy"]
    total_loss = loss + new_history.history["loss"]

    total_val_acc = val_acc + new_history.history["val_accuracy"]
    total_val_loss = val_loss + new_history.history["val_loss"]

    print(len(total_acc))
    print(total_acc)

    # Make plots
    plt.figure(figsize=(8, 8))
    plt.subplot(2, 1, 1)
    plt.plot(total_acc, label='Training Accuracy')
    plt.plot(total_val_acc, label='Validation Accuracy')
    plt.plot([initial_epochs-1, initial_epochs-1],
              plt.ylim(), label='Start Fine Tuning') # reshift plot around epochs
    plt.legend(loc='lower right')
    plt.title('Training and Validation Accuracy')
